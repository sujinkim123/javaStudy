/*
 * 		1. 데이터 => 메모리에 저장
 *         =======================
 *         1) 한개의 데이터 저장
 *            변경할 수 있다 ===> 변수
 *            변경할 수 없다 ===> 상수 (final)
 *            정수(int, long) , 실수(double) , 논리 (boolean:제어문) , 문자열(String)
 *            => 형식) 데이터형 변수명 = 값 (초기화)
 *         2) 같은 데이터형 여러개를 동시에 저장
 *            =============
 *         배열 : 인덱스 (메모리 연속적으로 배치) => 0부터 시작
 *         => 형식) 데이터형[] 배열명 = 값
 *                  = 데이터형[] 배열명 = {값1, 값2, ...}
 *                  = 데이터형[] 배열명 = new 데이터형[개수] 
 *                  =========================================
 *                     자동 초기화
 *                     int => 0 , long => 0L , boolean => false
 *                     String => null (주소가 없는 경우)
 *                     String s; => null
 *                     String s = "" => 공백이라는 값
 *         => 1차원 배열
 *      ============================================================================================
 *         3) 다른 데이터형을 여러개를 동시에 저장
 *            =============
 *            클래스 : 한개의 대한 모든 정보 => 영화정보 , 뮤직정보 , 사람정보....
 *                   여러개일 때 사용 => new를 사용하면 메모리가 다른 위치에 저장 
 *      ============================================================================================
 *         4) 메모리에 젖아 : RAM (휘발성) => 프로그램 종료시 사라진다
 *            = File (영구적으로 저장)
 *            *** = RDBMS (관계형 데이터베이스 *********) => 오라클, 마리아디비, MySQL => MongoDB
 *      ============================================================================================
 *   	2. 연산자 / 제어문
 *         데이터 처리 (요청) => 가공 
 *         연산자 : ++ , -- , ! , (type) , 산술연산자 , 비교연산자 , 논리연산자 , 대입(= , += , -=)
 *         제어문 : 조건문(if , if~else , 다중조건문) , 반복문(for, while) , 반복제어문(break)
 *         
 *         연산자 + 제어문 = 메소드 : 한개의 기능을 만들기 위해 명령문 여러개를 모아서 관리
 *                           ====== 재사용
 *      3. 프로그램 : 같은 기능끼리 묶어서 사용
 *      ========================================
 *         게시판 :
 *                   목록출력 => 메소드
 *                   글쓰기
 *                   내용보기
 *                   수정
 *                   답변
 *                   삭제
 *                   찾기
 *      ============================================================================================
 *      
 *      배열 : 같은 데이터형 => double[] arr = {10, 'A', ....}
 *                              double d=10; ===> d=10.0
 *                              double d='A'; ===> d=65.0 ===> 자동 형변환
 *                              대입 : 왼쪽에 있는 데이터형이 크거나 같다
 *             배열은 반드시 갯수를 지정 (length)
 *             1) int[] arr = {10, 20, 30, 40, 50} ==> 5개의 정수 메모리를 확보 (연속적)
 *             2) int[] arr = new int[개수];
 *             ============================== 단점 : 고정적 (갯수를 늘릴 경우에는 반드시 더 큰 배열을 생성)
 *                                                   복사를 한다
 *                                                   for => arraycopy()
 *             데이터가 저장된 메모리마다 인덱스번호를 부연한다 (0)
 *             int[] arr = {10, 20, 30, 40, 50};
 *             
 *             배열 시작의 주소(주소를 참조해서 데이터 가지고 오기) ==> 참조형 (배열, 클래스: 주소접그 연산자 '.' = 변수 + 메소드)
 *               Stack(주소)                      실제 데이터 저장(Heap)
 *                arr
 *               ======        ======================================================
 *                                 10   |    20   |    30    |     40    |    50
 *               ======        |=====================================================
 *                             100      104       108        112        116
 *                                arr[0]   arr[1]     arr[2]     arr[3]      arr[4]
 *                                ======
 *                                주소가 arr인 첫번째 값 : 데이터 읽기 (0) , 데이터 개수는 length-1
 *                                => for , while => 소스를 줄여서 사용이 가능
 *              => 정수형 선언
 *                 int[] 배열명 = {값...}
 *              => 문자열 선언
 *                 dobule[] 배열명 = {값...}
 *              => 문자열 선언
 *                 String[] 배열명 = {값...}
 *              => 배열 ==> 같은 데이터형 모아서 관리 (기능에 따라 모아서 관리)
 *                 예) 영화
 *                     영화명 , 감독 , 출연 , 장르 , 스토리 ===> 배열 5개 (인덱스를 처리)
 *                     ===================================== 인덱스 번호를 이용해서 만든다
 *                     
 */
// 1. 달력 ==> 사용자 (년도 / 월) ==> 요일 (난수 => 중복 => 숫자야구게임)
//    =========================== Calendar
/*
 *    달력 => 1년 1월 1일 ~ 현재까지의 총날 수 구한다 ==> %7 => 요일 구한다
 *    
 *    1. 전 년도까지 합
 *    2. 전 달까지 합
 *    3. 요청한 날짜까지
 *    =================== 총합
 *    %7 ==> 요일을 구한다
 */

// 입력 => Scanner
import java.util.Scanner;	// 기존에 만들어진 클래스를 불러올 때 사용 (라이브러리 (자바에서 제공.. 외부에서 제공), 사용자 정의)

// import => 전체 java.util.* , 한개씩 => java.util.클래스명
public class 자바기본문법 {
	public static void main(String[] args) {
		
		// 1. 사용자로부터 요청값을 받는다 ==> 프로그램 (Actor) : user
		// 키보드 입력값
		Scanner stdIn = new Scanner(System.in); // 입출력 (System.in System.out)
		System.out.print("년도 입력: ");
		int year = stdIn.nextInt();
		System.out.print("월 입력: ");
		int month = stdIn.nextInt();
		System.out.print("일 입력: ");
		int day = stdIn.nextInt();
		
		// 가공 ==> 요일을 출력
		// 1. 1년도 1월 1일부터 전 년도까지의 총 일수
		int total = (year-1) * 365 + (year-1)/4 
				                   - (year-1)/100 
				                   + (year-1)/400;	// 365, 366 => 윤년을 포함
		// 2. 전 달까지의 합
		int[] lastday = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}; // 365
		
		// 입력한 날짜가 윤년일 경우
		if ((year%4==0 && year%100!=0) || (year%400==0))
			lastday[1] = 29;
		else
			lastday[1] = 28;
		
		for(int i=0; i<month-1; i++) {
			total+=lastday[i];
		}
		
		// 요청한 일
		total += day;
		
		// 요일 구하기
		int week = total%7;
		
		String[] strWeek = {"일", "월", "화", "수", "목", "금", "토", "일"};
		System.out.printf("%d년 %d월 %d일은 %s요일입니다", year, month, day, strWeek[week]);
		
		/* switch(week) {
		case 0:
			System.out.printf("%d년 %d월 %d일은 일요일입니다", year, month, day);
			break;
		case 1:
			System.out.printf("%d년 %d월 %d일은 월요일입니다", year, month, day);
			break;
		case 2:
			System.out.printf("%d년 %d월 %d일은 화요일입니다", year, month, day);
			break;
		case 3:
			System.out.printf("%d년 %d월 %d일은 수요일입니다", year, month, day);
			break;
		case 4:
			System.out.printf("%d년 %d월 %d일은 목요일입니다", year, month, day);
			break;
		case 5:
			System.out.printf("%d년 %d월 %d일은 금요일입니다", year, month, day);
			break;
		case 6:
			System.out.printf("%d년 %d월 %d일은 토요일입니다", year, month, day);
			break;	
		}*/
		
		
	}
}
